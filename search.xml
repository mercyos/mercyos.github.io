<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[线程安全与非线程安全]]></title>
      <url>http://yoursite.com/2016/09/29/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E9%9D%9E%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/</url>
      <content type="html"><![CDATA[<h1 id="线程安全与非线程安全"><a href="#线程安全与非线程安全" class="headerlink" title="线程安全与非线程安全"></a>线程安全与非线程安全</h1><hr>
<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>　　<br>　　“非线程安全”是指多个线程对同一个对象中的实例变量（不在方法中定义的变量为成员变量，成员变量中中，static修饰的是静态成员变量，没有static修饰的是实例变量）。进行并发时访问，并将变量值改变，产生了“脏读”也就是取到的值与原本的不一样，发生了改变。“线程安全”是指获得的实例变量经过了同步加锁等处理，使值没有发生改变，不会发生“脏读”现象。</p>
<h2 id="方法内部的变量为线程安全"><a href="#方法内部的变量为线程安全" class="headerlink" title="方法内部的变量为线程安全"></a>方法内部的变量为线程安全</h2><p>　　</p>
<blockquote>
<p>“非线程安全”问题存在于“实例变量”中，如果是方法内部的私有变量，则不存在“非线程安全”问题，所得结果也就是“线程安全”的了。　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　<br>　　　　　　　　　     　———《java多线程编程核心技术》</p>
</blockquote>
<p>　　这句话需要深入的理解一下，“非线程安全”的主要原因是线程并发运行时，对变量产生了脏读，那么只要变量不会被产生脏读，则说明是安全的了。书上说：</p>
<blockquote>
<p>方法中的变量不存在非线程安全问题，永远是线程安全的。这是方法内部的变量的私有特性造成的。</p>
</blockquote>
<p>　　这句话不太好理解，我没想明白方法内部的变量的私有特性是什么意思，底层是怎样的。我知道方法内的变量是局部变量，在方法体内有效，出了方法体则被销毁回收。<br>　　先看一段代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedTest</span> </span>&#123;</div><div class="line"></div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">			HasSelfPrivateNum numRef = <span class="keyword">new</span> HasSelfPrivateNum();</div><div class="line">			ThreadA athread = <span class="keyword">new</span> ThreadA(numRef);</div><div class="line">			athread.start();</div><div class="line">			ThreadB bthread = <span class="keyword">new</span> ThreadB(numRef);</div><div class="line">			bthread.start();</div><div class="line">			</div><div class="line">		&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">HasSelfPrivateNum</span></span>&#123;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">int</span> num = <span class="number">0</span>;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addI</span><span class="params">(String username)</span></span>&#123;</div><div class="line"><span class="comment">//		int num = 0;</span></div><div class="line">		<span class="keyword">if</span>(username.equals(<span class="string">"a"</span>))&#123;</div><div class="line">			num = <span class="number">100</span>;</div><div class="line">			System.out.println(<span class="string">"a set over!"</span>);</div><div class="line">			<span class="keyword">try</span> &#123;</div><div class="line">				Thread.sleep(<span class="number">2000</span>);</div><div class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">				<span class="comment">// TODO Auto-generated catch block</span></div><div class="line">				e.printStackTrace();</div><div class="line">			&#125;</div><div class="line">		&#125;<span class="keyword">else</span>&#123;</div><div class="line">			num = <span class="number">200</span>;</div><div class="line">			System.out.println(<span class="string">"b set over!"</span>);</div><div class="line">		&#125;</div><div class="line">		System.out.println(username + <span class="string">"num = "</span> + num);</div><div class="line">		</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadA</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</div><div class="line">	<span class="keyword">private</span> HasSelfPrivateNum numRef;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ThreadA</span><span class="params">(HasSelfPrivateNum numRef)</span></span>&#123;</div><div class="line">		<span class="keyword">super</span>();</div><div class="line">		<span class="keyword">this</span>.numRef = numRef;</div><div class="line">	&#125; </div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">		<span class="keyword">super</span>.run();</div><div class="line">		numRef.addI(<span class="string">"a"</span>);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadB</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;,</div><div class="line">	<span class="keyword">private</span> HasSelfPrivateNum numRef;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ThreadB</span><span class="params">(HasSelfPrivateNum numRef)</span></span>&#123;</div><div class="line">		<span class="keyword">super</span>();</div><div class="line">		<span class="keyword">this</span>.numRef = numRef;</div><div class="line">	&#125; </div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">		<span class="keyword">super</span>.run();</div><div class="line">		numRef.addI(<span class="string">"b"</span>);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>　　问题主要集中在14行和16行情况下,num分别会打印什么，实验证明在14行情况下，num打印200，依旧是实例变量发生了脏读现象。而在16行，不会产生脏读现象，因为是在方法体内部定义的变量，也就是局部变量。<br>　　我的想法是发生脏读现象是因为线程对相同的变量进行的改写，那么也就是说方法体内部的变量并没有同时被多个线程所访问。由此可以推测，对于方法体内部的变量，每个线程调用是，都会各自创建一份，而不会共用一份。专业点说就是每个线程执行时将会吧局部变量放在<strong>各自栈帧</strong>的工作内存中，线程不共享，所以不存在线程安全问题。<br><img src="http://oe1t5gtpu.bkt.clouddn.com/3.png" alt="方法内局部变量的线程安全图例"></p>
<p>　　由此我们可以看出在线程在执行方法内局部变量是实在各自栈帧中运行的，互相之间不会干扰，不会发生脏读现象。而实例变量则是线程之间公用的（在内存分配上，局部变量在栈上，而实例变量则在堆上），所以一点某个线程改变了其值，则会影响到另一个线程，发生脏读现象。</p>
<hr>
<p>　　总结来说：<br>　　<strong>静态变量</strong>：线程非安全。静态变量即类变量，位于方法区，为所有对象共享，共享一份内存，一旦静态变量被修改，其他对象均对修改可见，故线程非安全。<br>　　<strong>实例变量</strong>：单例模式（只有一个对象实例存在）线程非安全，非单例线程安全。实例变量为对象实例私有，在虚拟机的堆中分配，若在系统中只存在一个此对象的实例，在多线程环境下，“犹如”静态变量那样，被某个线程修改后，其他线程对修改均可见，故线程非安全；如果每个线程执行都是在不同的对象中，那对象与对象之间的实例变量的修改将互不影响，故线程安全。<br>　　<strong>局部变量</strong>：线程安全。每个线程执行时将会把局部变量放在各自栈帧的工作内存中，线程间不共享，故不存在线程安全问题。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[基础的一些回顾]]></title>
      <url>http://yoursite.com/2016/09/25/%E5%9F%BA%E7%A1%80%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9B%9E%E9%A1%BE/</url>
      <content type="html"><![CDATA[<h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>　　今天突然对java基础有点犯晕，这里再思考巩固一下（看来还是理解不深刻呀，等差不多了好好研究下《深入理解jvm虚拟机》这本书）。<br>　　首先是先看一段代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Learn2</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> MAX_NUM = <span class="number">50</span>;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">int</span> num = <span class="number">100</span>;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		<span class="keyword">int</span> n = <span class="number">150</span>;</div><div class="line">		Learn2 lea = <span class="keyword">new</span> Learn2();</div><div class="line"><span class="comment">//		这里输出了MAX_NUM这个变量</span></div><div class="line">		System.out.println(MAX_NUM);</div><div class="line"><span class="comment">//		这里输出了num这个变量</span></div><div class="line"><span class="comment">//		System.out.println(num);</span></div><div class="line">		System.out.println(lea.num);</div><div class="line"><span class="comment">//		输出main函数中的n变量</span></div><div class="line">		System.out.println(n);</div><div class="line"><span class="comment">//		调用静态方法</span></div><div class="line">		<span class="keyword">int</span> d = Sum(<span class="number">3</span>,<span class="number">4</span>);	</div><div class="line">		System.out.println(<span class="string">"调用了静态方法"</span>);</div><div class="line">		Learn2 t = <span class="keyword">new</span> Learn2();</div><div class="line"><span class="comment">//		调用废静态方法</span></div><div class="line">		<span class="keyword">int</span> e = t.Sub(<span class="number">5</span>, <span class="number">3</span>);</div><div class="line">		System.out.println(<span class="string">"调用了非静态方法"</span>);</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">Sum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</div><div class="line">		<span class="keyword">return</span> a + b;</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Sub</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</div><div class="line">		<span class="keyword">return</span> a - b;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>　　我们一点一点分析：<br>　　首先区分变量，变量有全局变量与局部变量。在java里面全局也可以叫为成员变量。<br>　　局部变量是指在方法体内部的变量，例如在上面的例子里有main方法中的d,e,n三个变量。局部变量的作用范围是在其所属于的大括号内一直有效，出了大括号，也就失效被回收了。在这段范围呢可以直接被打印。<br>　　全局变量也叫成员变量，在这段代码中我们可以看到是类中定义的MAX_NUM和num，其中MAX_NUM是静态变量，num是非静态变量。这两个变量的作用范围也是在其所属于的大括号内，<strong>我们可以看出其所属于的大括号就是整个类，因此他们的作用范围在整个类中都有效，所以他们才被叫做全局变量，因为也可以被作为类的属性的定义，也可以被叫做成员变量。</strong><br>　　下面是之前犯迷糊的地方的解释了，在第12行和13行，第12行是有有错误的，这就牵扯到了非静态变量的深层次意义，非静态变量定义在栈内存中，再类没有实例化创建对象的时候是不存在的，只有类的对象被创建了才存在，因此是不能直接被打印的（例如第12行的出错），而第13行是先创建了一个叫lea的对象，这个对象中是有具体的num这个属性的，是从栈内存创建num变量然后传递到相应的对象中，已经具体存在了，然后打印lea.num这样是可以的。而静态变量则不是，其定义在了方法区，可以理解为已经存在了的，在方法区有其实体，属于整个类，不依托与具体的对象，也就是只要是这个类的对象就共有这一个静态变量，因此即时不创建类，这个静态变量也在方法区存在了，即时创建了100个对象也都是指向这一个静态变量，而不是随着对象不同产生了100个不同的变量。引用的时候只需要加上<strong>类.静态方法</strong>就行了。这个例子中是MAX_NUM这个变量。在第10行对其进行了打印，可以看到因为是静态变量，不需要实例化创建对象就能打印了，而由于是在自己所属的类中，可以省略<strong>类.静态方法</strong>中的类名，直接打上变量名就好了。当然实验显示加上类名也是对的（哎哟喂，好像变量输入只要是在<strong>自己的类</strong>中都不用加类名哇，之前就是这里脑抽犯迷糊了，自己的类嘛，自己还不认识了怎么滴，搞得这么生）。<br>　　所以嘛，有这么个定律<strong>静态方法中不能直接调用非静态的变量与方法，而是需要先创建对象！！</strong><br>　　看完变量，方法其实就很好理解了，方法就是指一段代码片段，方便重复引用的，当然也有静态与非静态，java这个体系都是依托为类，所以方法肯定也都是定义在某个类中（这不是废话吗？！）。就可以和变量一样，想为静态的定义在方法区，在其方法区内有这个方法实体，属于这个类，这个类所创建的对象都是共有这么一个<strong>静态方法</strong>的，即时创建了100个对象也都是指向这一个静态方法，而不是随着对象不同产生了100个不同的方法。代码样例中的16-18行。<br><img src="http://oe1t5gtpu.bkt.clouddn.com/pic1.png" alt="静态对象或方法的内存示意"></p>
<p>  　　而非静态方法则是只是一段代码片段，不存在一点实体，需要引用时和非静态变量一样，得先创建对象使之拥有相应对象的实体后，在进行<strong>对象.方法</strong>来引用。代码样例中的19-22行。</p>
<hr>
<p>　　以上是我这个新手暂时的理解，肯定不全面不具体，但是用起来好像也暂时没什么问题，就先这么理解着吧，以后还要加深巩固具体理解。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[线程的停止方式]]></title>
      <url>http://yoursite.com/2016/09/23/%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%81%9C%E6%AD%A2/</url>
      <content type="html"><![CDATA[<h1 id="线程的停止"><a href="#线程的停止" class="headerlink" title="线程的停止"></a>线程的停止</h1><hr>
<h2 id="判断线程是否停止"><a href="#判断线程是否停止" class="headerlink" title="判断线程是否停止"></a>判断线程是否停止</h2><p>　　两个用来判断线程停止的方法，分别是<br>　　<code>this.interrupted()</code><br>　　<code>this.isInterrupted()</code><br>这两中方法可以用来判断线程的停止状态。但是两者是有区别的。</p>
<blockquote>
<p>this.inturrupted()：测试当前的线程是否已经中断。<br>this.isInterrupted()：测试对象的线程是否中断.</p>
</blockquote>
<p>　　另外<code>this.inturrupted()</code>具有标志清楚功能，所以连续两次执行的话，第二次总是清除为false。而<code>this.isInterrupted()</code>则不清除状态，仅仅是测试Thread对象所代表的线程是否中断。</p>
<hr>
<h2 id="线程停止的方法"><a href="#线程停止的方法" class="headerlink" title="线程停止的方法"></a>线程停止的方法</h2><h3 id="异常法"><a href="#异常法" class="headerlink" title="异常法"></a>异常法</h3><p>　　首先来看一段具体的代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StopThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		Mythread thread = <span class="keyword">new</span> Mythread();</div><div class="line">		StopThread t = <span class="keyword">new</span> StopThread();</div><div class="line">		thread.start();</div><div class="line">		<span class="keyword">try</span> &#123;</div><div class="line">			Thread.sleep(<span class="number">2000</span>);</div><div class="line">			thread.interrupt();</div><div class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">			<span class="comment">// TODO Auto-generated catch block</span></div><div class="line">			System.out.println(<span class="string">"main catch"</span>);</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;</div><div class="line">		System.out.println(<span class="string">"end!!!"</span>);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mythread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">		<span class="keyword">super</span>.run();</div><div class="line">		<span class="keyword">try</span>&#123;	</div><div class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">500000</span>; i++)&#123;</div><div class="line">				<span class="keyword">if</span>(<span class="keyword">this</span>.interrupted())&#123;</div><div class="line">					System.out.println(<span class="string">"已经是停止状态!我要退出了"</span> );</div><div class="line"><span class="comment">//					break;</span></div><div class="line">					<span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</div><div class="line">				&#125;</div><div class="line">				System.out.println(<span class="string">"i = "</span> + i);</div><div class="line">			&#125;</div><div class="line">	<span class="comment">//		System.out.println("我被输出，如果次代码是for而又被运行，说明线程未被停止！！");</span></div><div class="line">			System.out.println(<span class="string">"我在for下面"</span>);</div><div class="line">		&#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</div><div class="line">			System.out.println(<span class="string">"进Mythread。java类run方法中的catch了！！"</span>);</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>　　通过对线程类的分析，其中的run()方法是在继承Threadrun()方法的基础上重写，首先循环50万次打印“i = XXX”在这期间，一旦被打断，则抛出异常（其中的break是为了做对比的，如果是break则此线程不会停止，而是继续，而如果是抛出异常，则进入异常处理，这代表这这个线程结束），然后异常处理打印“进入MyThread······”表示这个线程结束。所以main()方法中执行thread.interrupted()时，主动抛出异常，进入异常处理，线程结束。<strong>线程的停止就是将线程的运行语句结束，这里抛出异常可以达到目的。而break那个是不行的</strong>　　</p>
<p>###在沉睡中停止<br>　　首先来看一段代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//在线程睡的过程中，进行interrupt,然后接收到异常，停止线程</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StopInSleep</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		MyThread2 thread = <span class="keyword">new</span> MyThread2();</div><div class="line">		thread.start();</div><div class="line">		<span class="keyword">try</span> &#123;</div><div class="line">			Thread.sleep(<span class="number">200</span>);</div><div class="line">			thread.interrupt();</div><div class="line">			</div><div class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">			<span class="comment">// TODO Auto-generated catch block</span></div><div class="line">			System.out.println(<span class="string">"main catch"</span>);</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;</div><div class="line">		System.out.println(<span class="string">"end!!!"</span>);</div><div class="line">		System.out.println(thread.isInterrupted());</div><div class="line">		System.out.println(Thread.interrupted());</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread2</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">		<span class="keyword">super</span>.run();</div><div class="line">		System.out.println(<span class="string">"run begin!!"</span>);</div><div class="line">		<span class="keyword">try</span> &#123;</div><div class="line">			Thread.sleep(<span class="number">200000</span>);</div><div class="line">			System.out.println(<span class="string">"run end!!"</span>);</div><div class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">			<span class="comment">// TODO Auto-generated catch block</span></div><div class="line">			System.out.println(<span class="string">"在沉睡中被停止！进入catch！"</span> + <span class="keyword">this</span>.isInterrupted());</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>　　在这段代码中我们可以看到线程类在执行run()方法的过程中sleep了20秒。而在main()方法中线程开始后，主线程睡200ms,thread线程这时候被打断。<strong>sleep方法在被打断的时候会抛出InterruptedException异常</strong>，于是乎，进入了异常处理，代表着这个线程结束。其实和异常发的方法差不多一样，都是进入异常处理来结束。</p>
<hr>
<p>　　<strong>一点思考：</strong><del>这里我在16.17两行上打印了两个信息来确定线程是否停止了</del>，其中Thread代表主线程,主线程总是打印false，所以主线程是肯定没有停止的，而thread线程有时候是true有时候是false，<del>这说明当被打断后进入异常处理的过程中，主线程与处理过程是“并行”的，主线程在到打印thread.isInterrupted()的时候，异常处理可能还没有完全进入。若此时打印false，代表线程还未停止，也有可能进入了异常处理，若此时打印ture,则说明已经进入了异常处理，run()方法结束运行，线程结束了。若让主线程sleep()上1000ms时，此时肯定会打印false，也即说明此方法是有效的。</del> <strong>书上的说法是进入异常后，也即进入catch语句，清除停止状态值，使之变成false。</strong><br><strong>而在主线程中的此线程状态则不好判断，因为线程之间的执行进度与状态不确定：</strong></p>
<blockquote>
<p>调用interrupt()方法仅仅是在当前线程中打了一个停止的标记，并是不真的停止线程。</p>
</blockquote>
<p><strong>interrupt仅仅是传递了请求中断的信息，线程会在下一个方便的时间中断，因而，此时用interrupted()不确定其状态，但是总是会停止的。</strong></p>
<hr>
<h3 id="暴力停止stop"><a href="#暴力停止stop" class="headerlink" title="暴力停止stop()"></a>暴力停止stop()</h3><p>　　这种方法不推荐，已经废弃了。这个方法会抛出java.lang.ThreadDeath异常，但是此异常通常不需要捕捉。</p>
<hr>
<h3 id="使用return来停止线程"><a href="#使用return来停止线程" class="headerlink" title="使用return来停止线程"></a>使用return来停止线程</h3><p>　　首先看代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StopThreadReturn</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		MyThread3 thread = <span class="keyword">new</span> MyThread3();</div><div class="line">		thread.start();</div><div class="line">		<span class="keyword">try</span> &#123;</div><div class="line">			Thread.sleep(<span class="number">2000</span>);</div><div class="line">			thread.interrupt();</div><div class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">			<span class="comment">// TODO Auto-generated catch block</span></div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread3</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">		<span class="keyword">super</span>.run();</div><div class="line">		<span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</div><div class="line">			<span class="keyword">if</span>(<span class="keyword">this</span>.isInterrupted())&#123;</div><div class="line">				System.out.println(<span class="string">"停止了！"</span>);</div><div class="line">				<span class="keyword">return</span>;</div><div class="line">			&#125;</div><div class="line">			System.out.println(<span class="string">"timer = "</span> + System.currentTimeMillis());</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<hr>
<p>　　<strong>不过还是建议使用抛异常的方法来实现线程的停止，这样能够在catch块中将异常向上抛，使线程的停止事件得到传播。</strong></p>
<hr>
<h3 id="自己的思考："><a href="#自己的思考：" class="headerlink" title="自己的思考："></a><strong>自己的思考：</strong></h3><p>　　停止线程的主要目的就是结束run()方法，而interrupted只是打一个标记，不能直接结束run()方法，但是能在线程上打上一个标记，因此就在打上标记的时刻让run()方法进入异常或直接return返回值来结束，也就是让线程停止。<br>　　一旦执行interrupt打断，那么就会立刻打上一个打断标记（<em>虽然run()方法还没结束,这需要用异常或return或stop()等来结束</em>）。而停止线程方法用异常时，一旦进入异常，又会擦除停止状态值，使之成为false，<strong>而进入异常是有个过程的</strong>，在进入异常的过程中，这个状态值还是true，此时如果主线程isInterrrupted()打印了状态值，就是true，而如果进入异常再打印，那就是false。<br>　　<strong>由此我们可以看出，线程的停止是interrupt与停止（异常等）方法相互配合来完成的。</strong><br>　　而主线程里又有main线程，两个线程互相运行，只能说在当前线程里判断最为准确，例如在主线程里判断thread这样的新启动线程的状态是不一定很准确的。<br>　　所以我个人经验是，判断线程的状态，最好实在自己线程内判断，不要新线程的状态在主线程里判断。否则可能由于线程间的进度问题，造成结果不相同，不准确。<br>　　我的测试方法是比较return和异常来停止线程，再在主线程里进行状态判断，结果是return结果很准确很稳定。而异常不一定准确与稳定。因为进入异常是要擦除中断状态值的，造成状态值改变的问题。而return不需要，因此return是准确的。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[hello hexo]]></title>
      <url>http://yoursite.com/2016/09/22/test1/</url>
      <content type="html"><![CDATA[<p>This is a test for categories and tags!!</p>
<p>end!!!</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>http://yoursite.com/2016/09/21/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    </entry>
    
  
  
</search>
